# Git

## HEAD
به ما نشان میدهد در کجا قرار داریم

## Remote
دستور git remote امکان ایجاد، مشاهده و حذف ارتباط با مخزن های دیگر را به شما می دهد. اتصال های از راه دور بیشتر شبیه نشانه گذاری (bookmark) ها هستند تا لینک مستقیم به مخزن های دیگر. آن ها به جای دسترسی سریع (real-time)به مخزن دیگر، به عنوان نام های مناسبی هستند که می توانند برای آدرس (URL) های نه چندان خوانا باشند.  

دستور زیر لیست اتصال های از راه دور را فهرست می کند. 
``` bash
git remote
```
این دستور مانند دستور بالا است، اما آدرس هر اتصال را نیز در خروجی نمایش می دهد.

``` bash
git remote add <name> <url>
```
با استفاده از دستور بالا، اتصال جدیدی به یک مخزن از راه دور ایجاد کنید. پس از افزودن یک اتصال از راه دور، می توانید به عنوان میانبر مناسب برای سایر دستورهای Git استفاده کنید.


``` bash
git remote rm <name>
```
اتصال به مخزن از راه دور را حذف کنید.

``` bash
git remote rename <old-name> <new-name>
```
نام اتصال از راه دور را به نام جدید تغییر دهید. 


## Merge
دستور git merge چندین commit را به یک تاریخچه ی واحد متصل می کند.
<br>
مثال:
```bash
# Start a new feature
git checkout -b new-feature main
# Edit some files
git add <file>
git commit -m "Start a feature"
# Edit some files
git add <file>
git commit -m "Finish a feature"
# Merge in the new-feature branch
git checkout main
git merge new-feature
git branch -d new-feature
```
## Rebase
وقتی rebase می‌کنیم، گیت کامیت های برنچی که با اون rebase کردیم رو میاره پشت سر کامیت های برنچ ما قرار میده (از جایی که برنچ ما جدا شده) و کامیت های ما در انتهای اون قرار می‌ده. تا اینجا مشکلی نیست، تنها نکته اینه که کامیت های ما که در انتها قرار می‌گیرن، از نظر message و description و ... کاملا با کامیت های قبلی یکی هستند ولی sha متفاوتی دارن. یعنی وقتی مجدد روی branch خودمون push می‌کنیم روی remote کامیت های متفاوتی وجود داره و به همین دلیل بدون force کردن امکان push وجود نداره.

``` bash
git rebase -m "initail"
```
## Revert
## Cherry Pick
## Pull Request
## Submodules
برای اضافه کردن Submodules به یک پروژه نیاز هست دستور زیر رو وارد کنیم:

``` bash
git submodule add https://github.com/MHKarami97/Submodules
```
برای کلون کردن پروژه اصلی که از ماژول های دیگه داخلش استفاده شده، علاوه بر دستور git clone ... که فایل های پروژه اصلی رو میگیره، نیاز به اجرای دستور زیر هم هست:
``` bash
git submodule init
```
و سپس برای آپدیت کردن و دریافت آخرین نسخه ماژول ها دستور زیر رو وارد کنید:
``` bash
git submodule update
```
## Reset
## Working area VS Staging area
## bisect
دستور git bisect در حقیقت مخفف git binary search commit هست. ما وقتی ازین دستور استفاده می‌کنیم که در روند توسعه پروژه به باگ خوردیم و حالا می‌خوایم بدونیم که این باگ چه زمانی در کدوم کامیت پیدا شده و از طرفی کدوم ورژن از repositoryمون bug free هست. git bisect اینکارو با بررسی کامیت‌ها برامون انجام میده.
``` bash
git bisect start
```

اول از همه باید مشخص کنیم که در حال حاضر ما در این کامیتی که هستیم باگ داریم و یا به عبارتی اوضاع بده! پس با دستور زیر این رو به گیت میفهمونیم
``` bash
git bisect bad
```
و بعد ازین، در مرحله بعد باید یکی از کامیت‌هایی که می‌دونیم در اون باگ نداشتیم رو به گیت معرفی کنیم و بگیم که در اون کامیت اوضاع خوب بوده. برای این کار به آی‌دی اون کامیتی که می‌دونیم بدون باگ بوده نیاز داریم، تا بتونیم ازین طریق به گیت معرفیش کنیم.

``` bash
git bisect good  3799573c07ae56555(#commit ID)
```

``` bash
git bisect good 
```